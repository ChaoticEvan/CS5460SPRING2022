Notes[36m:[m    also protects next_[1;31mpid[m
TRICKS[36m:[mThe code in fork needs to read np->[1;31mpid[m before
TRICKS[36m:[m	  return np->[1;31mpid[m; // oops
TRICKS[36m:[mget reused for a different process (with a new [1;31mpid[m), all
TRICKS[36m:[m"return np->[1;31mpid[m". Even saving a copy of np->[1;31mpid[m before
TRICKS[36m:[mThe real code saves a copy of np->[1;31mpid[m, then acquires a lock
Binary file _cat matches
Binary file _echo matches
Binary file _forktest matches
Binary file _freemem matches
Binary file _grep matches
Binary file _init matches
Binary file _kill matches
Binary file _ln matches
Binary file _ls matches
Binary file _mkdir matches
Binary file _rm matches
Binary file _sh matches
Binary file _stressfs matches
Binary file _usertests matches
Binary file _wc matches
Binary file _zombie matches
Binary file bio.o matches
cat.asm[36m:[m000003e1 <get[1;31mpid[m>:
cat.asm[36m:[mSYSCALL(get[1;31mpid[m)
cat.sym[36m:[m000003e1 get[1;31mpid[m
Binary file console.o matches
echo.asm[36m:[m00000341 <get[1;31mpid[m>:
echo.asm[36m:[mSYSCALL(get[1;31mpid[m)
echo.sym[36m:[m00000341 get[1;31mpid[m
Binary file exec.o matches
Binary file file.o matches
forktest.asm[36m:[m    if([1;31mpid[m == 0)
forktest.asm[36m:[m    [1;31mpid[m = fork();
forktest.asm[36m:[m    if([1;31mpid[m < 0)
forktest.asm[36m:[m00000411 <get[1;31mpid[m>:
forktest.asm[36m:[mSYSCALL(get[1;31mpid[m)
forktest.c[36m:[m  int n, [1;31mpid[m;
forktest.c[36m:[m    [1;31mpid[m = fork();
forktest.c[36m:[m    if([1;31mpid[m < 0)
forktest.c[36m:[m    if([1;31mpid[m == 0)
Binary file forktest.o matches
freemem.asm[36m:[m00000311 <get[1;31mpid[m>:
freemem.asm[36m:[mSYSCALL(get[1;31mpid[m)
freemem.sym[36m:[m00000311 get[1;31mpid[m
Binary file fs.img matches
Binary file fs.o matches
grep.asm[36m:[m00000611 <get[1;31mpid[m>:
grep.asm[36m:[mSYSCALL(get[1;31mpid[m)
grep.sym[36m:[m00000611 get[1;31mpid[m
Binary file ide.o matches
init.asm[36m:[m  int [1;31mpid[m, w[1;31mpid[m;
init.asm[36m:[m    [1;31mpid[m = fork();
init.asm[36m:[m    if([1;31mpid[m < 0){
init.asm[36m:[m    [1;31mpid[m = fork();
init.asm[36m:[m    if([1;31mpid[m < 0){
init.asm[36m:[m    if([1;31mpid[m == 0){
init.asm[36m:[m    while((w[1;31mpid[m=wait()) >= 0 && w[1;31mpid[m != [1;31mpid[m)
init.asm[36m:[m000003c1 <get[1;31mpid[m>:
init.asm[36m:[mSYSCALL(get[1;31mpid[m)
init.c[36m:[m  int [1;31mpid[m, w[1;31mpid[m;
init.c[36m:[m    [1;31mpid[m = fork();
init.c[36m:[m    if([1;31mpid[m < 0){
init.c[36m:[m    if([1;31mpid[m == 0){
init.c[36m:[m    while((w[1;31mpid[m=wait()) >= 0 && w[1;31mpid[m != [1;31mpid[m)
Binary file init.o matches
init.sym[36m:[m000003c1 get[1;31mpid[m
Binary file kernel matches
kernel.asm[36m:[m  p->[1;31mpid[m = next[1;31mpid[m++;
kernel.asm[36m:[m  p->[1;31mpid[m = next[1;31mpid[m++;
kernel.asm[36m:[m  p->[1;31mpid[m = next[1;31mpid[m++;
kernel.asm[36m:[m  [1;31mpid[m = np->[1;31mpid[m;
kernel.asm[36m:[m  return [1;31mpid[m;
kernel.asm[36m:[m        [1;31mpid[m = p->[1;31mpid[m;
kernel.asm[36m:[m        p->[1;31mpid[m = 0;
kernel.asm[36m:[m        return [1;31mpid[m;
kernel.asm[36m:[m// Kill the process with the given [1;31mpid[m.
kernel.asm[36m:[mkill(int [1;31mpid[m)
kernel.asm[36m:[m    if(p->[1;31mpid[m == [1;31mpid[m){
kernel.asm[36m:[m    cprintf("%d %s %s", p->[1;31mpid[m, state, p->name);
kernel.asm[36m:[m  lk->[1;31mpid[m = 0;
kernel.asm[36m:[m  lk->[1;31mpid[m = 0;
kernel.asm[36m:[m  lk->[1;31mpid[m = myproc()->[1;31mpid[m;
kernel.asm[36m:[m  lk->[1;31mpid[m = 0;
kernel.asm[36m:[m  r = lk->locked && (lk->[1;31mpid[m == myproc()->[1;31mpid[m);
kernel.asm[36m:[m  r = lk->locked && (lk->[1;31mpid[m == myproc()->[1;31mpid[m);
kernel.asm[36m:[m            curproc->[1;31mpid[m, curproc->name, num);
kernel.asm[36m:[m            curproc->[1;31mpid[m, curproc->name, num);
kernel.asm[36m:[m  int [1;31mpid[m;
kernel.asm[36m:[m  if(argint(0, &[1;31mpid[m) < 0)
kernel.asm[36m:[m  return kill([1;31mpid[m);
kernel.asm[36m:[m80105610 <sys_get[1;31mpid[m>:
kernel.asm[36m:[msys_get[1;31mpid[m(void)
kernel.asm[36m:[m  return myproc()->[1;31mpid[m;
kernel.asm[36m:[m    cprintf("[1;31mpid[m %d %s: trap %d err %d on cpu %d "
kernel.asm[36m:[m            myproc()->[1;31mpid[m, myproc()->name, tf->trapno,
kernel.asm[36m:[m    cprintf("[1;31mpid[m %d %s: trap %d err %d on cpu %d "
kernel.asm[36m:[m            myproc()->[1;31mpid[m, myproc()->name, tf->trapno,
kernel.asm[36m:[m    cprintf("[1;31mpid[m %d %s: trap %d err %d on cpu %d "
kernel.asm[36m:[m            myproc()->[1;31mpid[m, myproc()->name, tf->trapno,
kernel.asm[36m:[m    cprintf("[1;31mpid[m %d %s: trap %d err %d on cpu %d "
kernel.sym[36m:[m8010a004 next[1;31mpid[m
kernel.sym[36m:[m80105610 sys_get[1;31mpid[m
kill.asm[36m:[m    printf(2, "usage: kill [1;31mpid[m...\n");
kill.asm[36m:[m    printf(2, "usage: kill [1;31mpid[m...\n");
kill.asm[36m:[m00000331 <get[1;31mpid[m>:
kill.asm[36m:[mSYSCALL(get[1;31mpid[m)
kill.c[36m:[m    printf(2, "usage: kill [1;31mpid[m...\n");
Binary file kill.o matches
kill.sym[36m:[m00000331 get[1;31mpid[m
ln.asm[36m:[m00000331 <get[1;31mpid[m>:
ln.asm[36m:[mSYSCALL(get[1;31mpid[m)
ln.sym[36m:[m00000331 get[1;31mpid[m
Binary file log.o matches
ls.asm[36m:[m00000621 <get[1;31mpid[m>:
ls.asm[36m:[mSYSCALL(get[1;31mpid[m)
ls.sym[36m:[m00000621 get[1;31mpid[m
Binary file main.o matches
mkdir.asm[36m:[m00000351 <get[1;31mpid[m>:
mkdir.asm[36m:[mSYSCALL(get[1;31mpid[m)
mkdir.sym[36m:[m00000351 get[1;31mpid[m
Binary file mp.o matches
Binary file pipe.o matches
proc.c[36m:[mint next[1;31mpid[m = 1;
proc.c[36m:[m  p->[1;31mpid[m = next[1;31mpid[m++;
proc.c[36m:[m  int i, [1;31mpid[m;
proc.c[36m:[m  [1;31mpid[m = np->[1;31mpid[m;
proc.c[36m:[m  return [1;31mpid[m;
proc.c[36m:[m// Wait for a child process to exit and return its [1;31mpid[m.
proc.c[36m:[m  int havekids, [1;31mpid[m;
proc.c[36m:[m        [1;31mpid[m = p->[1;31mpid[m;
proc.c[36m:[m        p->[1;31mpid[m = 0;
proc.c[36m:[m        return [1;31mpid[m;
proc.c[36m:[m// Kill the process with the given [1;31mpid[m.
proc.c[36m:[mkill(int [1;31mpid[m)
proc.c[36m:[m    if(p->[1;31mpid[m == [1;31mpid[m){
proc.c[36m:[m    cprintf("%d %s %s", p->[1;31mpid[m, state, p->name);
proc.h[36m:[m  int [1;31mpid[m;                     // Process ID
Binary file proc.o matches
rm.asm[36m:[m00000351 <get[1;31mpid[m>:
rm.asm[36m:[mSYSCALL(get[1;31mpid[m)
rm.sym[36m:[m00000351 get[1;31mpid[m
sh.asm[36m:[m  int [1;31mpid[m;
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  [1;31mpid[m = fork();
sh.asm[36m:[m  if([1;31mpid[m == -1)
sh.asm[36m:[m  return [1;31mpid[m;
sh.asm[36m:[m00000db1 <get[1;31mpid[m>:
sh.asm[36m:[mSYSCALL(get[1;31mpid[m)
sh.c[36m:[m  int [1;31mpid[m;
sh.c[36m:[m  [1;31mpid[m = fork();
sh.c[36m:[m  if([1;31mpid[m == -1)
sh.c[36m:[m  return [1;31mpid[m;
Binary file sh.o matches
sh.sym[36m:[m00000db1 get[1;31mpid[m
sleep1.p[36m:[m	assert !sleeping[_[1;31mpid[m];
sleep1.p[36m:[m		atomic { release(lk); sleeping[_[1;31mpid[m] = 1 };
sleep1.p[36m:[m		sleeping[_[1;31mpid[m] == 0;
sleeplock.c[36m:[m  lk->[1;31mpid[m = 0;
sleeplock.c[36m:[m  lk->[1;31mpid[m = myproc()->[1;31mpid[m;
sleeplock.c[36m:[m  lk->[1;31mpid[m = 0;
sleeplock.c[36m:[m  r = lk->locked && (lk->[1;31mpid[m == myproc()->[1;31mpid[m);
sleeplock.h[36m:[m  int [1;31mpid[m;           // Process holding lock
Binary file sleeplock.o matches
Binary file spinlock.o matches
stressfs.asm[36m:[m00000411 <get[1;31mpid[m>:
stressfs.asm[36m:[mSYSCALL(get[1;31mpid[m)
stressfs.sym[36m:[m00000411 get[1;31mpid[m
syscall.c[36m:[mextern int sys_get[1;31mpid[m(void);
syscall.c[36m:[m[SYS_get[1;31mpid[m]  sys_get[1;31mpid[m,
syscall.c[36m:[m            curproc->[1;31mpid[m, curproc->name, num);
syscall.h[36m:[m#define SYS_get[1;31mpid[m 11
Binary file syscall.o matches
Binary file sysfile.o matches
sysproc.c[36m:[m  int [1;31mpid[m;
sysproc.c[36m:[m  if(argint(0, &[1;31mpid[m) < 0)
sysproc.c[36m:[m  return kill([1;31mpid[m);
sysproc.c[36m:[msys_get[1;31mpid[m(void)
sysproc.c[36m:[m  return myproc()->[1;31mpid[m;
Binary file sysproc.o matches
trap.c[36m:[m    cprintf("[1;31mpid[m %d %s: trap %d err %d on cpu %d "
trap.c[36m:[m            myproc()->[1;31mpid[m, myproc()->name, tf->trapno,
Binary file trap.o matches
Binary file uart.o matches
user.h[36m:[mint get[1;31mpid[m(void);
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m < 0){
usertests.asm[36m:[m  if([1;31mpid[m == 0){
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m < 0){
usertests.asm[36m:[m  if([1;31mpid[m == 0){
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m == 0){
usertests.asm[36m:[m  } else if([1;31mpid[m > 0){
usertests.asm[36m:[m  [1;31mpid[m1 = fork();
usertests.asm[36m:[m  if([1;31mpid[m1 == 0)
usertests.asm[36m:[m  [1;31mpid[m2 = fork();
usertests.asm[36m:[m  if([1;31mpid[m2 == 0)
usertests.asm[36m:[m  [1;31mpid[m3 = fork();
usertests.asm[36m:[m  if([1;31mpid[m3 == 0){
usertests.asm[36m:[m  [1;31mpid[m3 = fork();
usertests.asm[36m:[m  if([1;31mpid[m3 == 0){
usertests.asm[36m:[m  kill([1;31mpid[m1);
usertests.asm[36m:[m  kill([1;31mpid[m2);
usertests.asm[36m:[m  kill([1;31mpid[m3);
usertests.asm[36m:[m    if([1;31mpid[m){
usertests.asm[36m:[m      if(wait() != [1;31mpid[m){
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0){
usertests.asm[36m:[m        printf(1, "wait wrong [1;31mpid[m\n");
usertests.asm[36m:[m  p[1;31mpid[m = get[1;31mpid[m();
usertests.asm[36m:[m     da7:	e8 a5 2b 00 00       	call   3951 <get[1;31mpid[m>
usertests.asm[36m:[m  if(([1;31mpid[m = fork()) == 0){
usertests.asm[36m:[m      kill(p[1;31mpid[m);
usertests.asm[36m:[m  memset(buf, [1;31mpid[m==0?'c':'p', sizeof(buf));
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  memset(buf, [1;31mpid[m==0?'c':'p', sizeof(buf));
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  memset(buf, [1;31mpid[m==0?'c':'p', sizeof(buf));
usertests.asm[36m:[m  if([1;31mpid[m == 0)
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0){
usertests.asm[36m:[m    if([1;31mpid[m == 0){
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0){
usertests.asm[36m:[m    if([1;31mpid[m == 0){
usertests.asm[36m:[m    if([1;31mpid[m && (i % 3) == 1){
usertests.asm[36m:[m    if([1;31mpid[m && (i % 3) == 1){
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m && (i % 3) == 1){
usertests.asm[36m:[m    } else if([1;31mpid[m == 0 && (i % 5) == 1){
usertests.asm[36m:[m       ((i % 3) == 1 && [1;31mpid[m != 0)){
usertests.asm[36m:[m    if([1;31mpid[m == 0)
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0){
usertests.asm[36m:[m    if(((i % 3) == 0 && [1;31mpid[m == 0) ||
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m < 0){
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m < 0){
usertests.asm[36m:[m  unsigned int x = ([1;31mpid[m ? 1 : 97);
usertests.asm[36m:[m  unsigned int x = ([1;31mpid[m ? 1 : 97);
usertests.asm[36m:[m  if([1;31mpid[m)
usertests.asm[36m:[m    if([1;31mpid[m == 0)
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0)
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m < 0){
usertests.asm[36m:[m  if([1;31mpid[m == 0)
usertests.asm[36m:[m    p[1;31mpid[m = get[1;31mpid[m();
usertests.asm[36m:[m    2ed8:	e8 74 0a 00 00       	call   3951 <get[1;31mpid[m>
usertests.asm[36m:[m    [1;31mpid[m = fork();
usertests.asm[36m:[m    if([1;31mpid[m < 0){
usertests.asm[36m:[m    if([1;31mpid[m == 0){
usertests.asm[36m:[m    if(([1;31mpid[ms[i] = fork()) == 0){
usertests.asm[36m:[m    if([1;31mpid[ms[i] != -1)
usertests.asm[36m:[m  for(i = 0; i < sizeof([1;31mpid[ms)/sizeof([1;31mpid[ms[0]); i++){
usertests.asm[36m:[m    if([1;31mpid[ms[i] == -1)
usertests.asm[36m:[m    kill([1;31mpid[ms[i]);
usertests.asm[36m:[m  for(i = 0; i < sizeof([1;31mpid[ms)/sizeof([1;31mpid[ms[0]); i++){
usertests.asm[36m:[m      kill(p[1;31mpid[m);
usertests.asm[36m:[m    if(([1;31mpid[m = fork()) == 0){
usertests.asm[36m:[m    kill([1;31mpid[m);
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m == 0){
usertests.asm[36m:[m  } else if([1;31mpid[m < 0){
usertests.asm[36m:[m  [1;31mpid[m = fork();
usertests.asm[36m:[m  if([1;31mpid[m == 0){
usertests.asm[36m:[m  } else if([1;31mpid[m < 0){
usertests.asm[36m:[m00003951 <get[1;31mpid[m>:
usertests.asm[36m:[mSYSCALL(get[1;31mpid[m)
usertests.c[36m:[m  int [1;31mpid[m;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m < 0){
usertests.c[36m:[m  if([1;31mpid[m == 0){
usertests.c[36m:[m  int [1;31mpid[m;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m < 0){
usertests.c[36m:[m  if([1;31mpid[m == 0){
usertests.c[36m:[m  int fds[2], [1;31mpid[m;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m == 0){
usertests.c[36m:[m  } else if([1;31mpid[m > 0){
usertests.c[36m:[m  int [1;31mpid[m1, [1;31mpid[m2, [1;31mpid[m3;
usertests.c[36m:[m  [1;31mpid[m1 = fork();
usertests.c[36m:[m  if([1;31mpid[m1 == 0)
usertests.c[36m:[m  [1;31mpid[m2 = fork();
usertests.c[36m:[m  if([1;31mpid[m2 == 0)
usertests.c[36m:[m  [1;31mpid[m3 = fork();
usertests.c[36m:[m  if([1;31mpid[m3 == 0){
usertests.c[36m:[m  kill([1;31mpid[m1);
usertests.c[36m:[m  kill([1;31mpid[m2);
usertests.c[36m:[m  kill([1;31mpid[m3);
usertests.c[36m:[m  int i, [1;31mpid[m;
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0){
usertests.c[36m:[m    if([1;31mpid[m){
usertests.c[36m:[m      if(wait() != [1;31mpid[m){
usertests.c[36m:[m        printf(1, "wait wrong [1;31mpid[m\n");
usertests.c[36m:[m  int [1;31mpid[m, p[1;31mpid[m;
usertests.c[36m:[m  p[1;31mpid[m = get[1;31mpid[m();
usertests.c[36m:[m  if(([1;31mpid[m = fork()) == 0){
usertests.c[36m:[m      kill(p[1;31mpid[m);
usertests.c[36m:[m  int fd, [1;31mpid[m, i, n, nc, np;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  memset(buf, [1;31mpid[m==0?'c':'p', sizeof(buf));
usertests.c[36m:[m  if([1;31mpid[m == 0)
usertests.c[36m:[m  int fd, [1;31mpid[m, i, j, n, total, pi;
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0){
usertests.c[36m:[m    if([1;31mpid[m == 0){
usertests.c[36m:[m  int [1;31mpid[m, i, fd, pi;
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0){
usertests.c[36m:[m    if([1;31mpid[m == 0){
usertests.c[36m:[m  int i, [1;31mpid[m, n, fd;
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m && (i % 3) == 1){
usertests.c[36m:[m    } else if([1;31mpid[m == 0 && (i % 5) == 1){
usertests.c[36m:[m    if([1;31mpid[m == 0)
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0){
usertests.c[36m:[m    if(((i % 3) == 0 && [1;31mpid[m == 0) ||
usertests.c[36m:[m       ((i % 3) == 1 && [1;31mpid[m != 0)){
usertests.c[36m:[m    if([1;31mpid[m == 0)
usertests.c[36m:[m  int [1;31mpid[m, i;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m < 0){
usertests.c[36m:[m  unsigned int x = ([1;31mpid[m ? 1 : 97);
usertests.c[36m:[m  if([1;31mpid[m)
usertests.c[36m:[m  int n, [1;31mpid[m;
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0)
usertests.c[36m:[m    if([1;31mpid[m == 0)
usertests.c[36m:[m  int fds[2], [1;31mpid[m, [1;31mpid[ms[10], p[1;31mpid[m;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m < 0){
usertests.c[36m:[m  if([1;31mpid[m == 0)
usertests.c[36m:[m    p[1;31mpid[m = get[1;31mpid[m();
usertests.c[36m:[m    [1;31mpid[m = fork();
usertests.c[36m:[m    if([1;31mpid[m < 0){
usertests.c[36m:[m    if([1;31mpid[m == 0){
usertests.c[36m:[m      kill(p[1;31mpid[m);
usertests.c[36m:[m  for(i = 0; i < sizeof([1;31mpid[ms)/sizeof([1;31mpid[ms[0]); i++){
usertests.c[36m:[m    if(([1;31mpid[ms[i] = fork()) == 0){
usertests.c[36m:[m    if([1;31mpid[ms[i] != -1)
usertests.c[36m:[m  for(i = 0; i < sizeof([1;31mpid[ms)/sizeof([1;31mpid[ms[0]); i++){
usertests.c[36m:[m    if([1;31mpid[ms[i] == -1)
usertests.c[36m:[m    kill([1;31mpid[ms[i]);
usertests.c[36m:[m  int hi, [1;31mpid[m;
usertests.c[36m:[m    if(([1;31mpid[m = fork()) == 0){
usertests.c[36m:[m    kill([1;31mpid[m);
usertests.c[36m:[m  int [1;31mpid[m, fd;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m == 0){
usertests.c[36m:[m  } else if([1;31mpid[m < 0){
usertests.c[36m:[m  int [1;31mpid[m;
usertests.c[36m:[m  [1;31mpid[m = fork();
usertests.c[36m:[m  if([1;31mpid[m == 0){
usertests.c[36m:[m  } else if([1;31mpid[m < 0){
Binary file usertests.o matches
usertests.sym[36m:[m00003951 get[1;31mpid[m
usys.S[36m:[mSYSCALL(get[1;31mpid[m)
Binary file usys.o matches
Binary file vm.o matches
wc.asm[36m:[m00000451 <get[1;31mpid[m>:
wc.asm[36m:[mSYSCALL(get[1;31mpid[m)
wc.sym[36m:[m00000451 get[1;31mpid[m
Binary file xv6.img matches
zombie.asm[36m:[m00000301 <get[1;31mpid[m>:
zombie.asm[36m:[mSYSCALL(get[1;31mpid[m)
zombie.sym[36m:[m00000301 get[1;31mpid[m
